<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D模型展示</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { 
            overflow: hidden; 
        }
        button {
            padding: 10px 20px;
            background: #a099ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            font-size:13px;
        }


    </style>
</head>
<body>
    <button id="scoreButton">评分</button>



    <script>
        // 创建场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // 创建相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // 加载GLB模型
        const loader = new THREE.GLTFLoader();
        loader.setCrossOrigin('anonymous'); 
        
        function loadModel(modelPath){
            loader.load(modelPath, function(gltf) {
                const model = gltf.scene;
                scene.add(model);
                
                // 自动调整模型大小和位置
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                model.position.x = -center.x;
                model.position.y = -center.y;
                model.position.z = -center.z;
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2 / maxDim;
                model.scale.multiplyScalar(scale);
                
                // 动画循环
                function animate() {
                    requestAnimationFrame(animate);
                    model.rotation.y += 0.01; // 自动旋转
                    renderer.render(scene, camera);
                }
                animate();
            }, undefined, function(error) {
                console.error('模型加载失败:', error);
                alert('模型加载失败，请检查文件路径是否正确。');
            });

        }
        document.addEventListener('DOMContentLoaded', function() {
            // 从localStorage读取数据
            const modelData = getLatestModelData();

            if (modelData) {
                console.log('成功读取模型数据:', modelData);
                
                // 原来的数据处理逻辑保持不变，只是数据来源变了
                if (modelData.model_path) {
                    // 这里使用 modelData.model_path 而不是原来的 data.model_path
                    loadModel(modelData.model_path);
                }
            } else {
                console.error('未能获取模型数据，显示默认内容或错误信息');
                // 显示错误信息或默认内容
            }
            // 获取评分按钮
            const scoreButton = document.getElementById('scoreButton');
            if (scoreButton) {
                scoreButton.addEventListener('click', function() {
                    // 弹出输入框让用户输入分数
                    let score = prompt('请输入评分（0-10分）:');
                    if (score !== null) { // 用户没有点击取消
                        // 将输入转换为数字
                        score = parseFloat(score);
                        if (isNaN(score) || score < 0 || score > 10) {
                            alert('请输入0-10之间的数字！');
                            return;
                        }

                        // 获取最新数据的键
                        const keyList = JSON.parse(localStorage.getItem('modelDataKeys') || '[]');
                        if (keyList.length === 0) {
                            alert('没有找到可评分的数据！');
                            return;
                        }
                        const latestKey = keyList[keyList.length - 1];

                        // 获取最新数据
                        const storedData = localStorage.getItem(latestKey);
                        if (storedData) {
                            const modelData = JSON.parse(storedData);
                            // 添加分数
                            modelData.score = score;
                            // 保存回localStorage
                            localStorage.setItem(latestKey, JSON.stringify(modelData));
                            alert('评分成功！');
                        } else {
                            alert('数据不存在，无法评分！');
                        }
                    }
                });
            }
            
           
        });
        
        // 获取最新的模型数据
        function getLatestModelData() {
            try {
                // 获取键名列表
                const keyList = JSON.parse(localStorage.getItem('modelDataKeys') || '[]');
                
                if (keyList.length === 0) {
                    console.warn('没有找到存储的模型数据');
                    return null;
                }
                
                // 获取最后一个键（最新的数据）
                const latestKey = keyList[keyList.length - 1];
                const storedData = localStorage.getItem(latestKey);
                
                if (!storedData) {
                    console.warn('最新数据不存在，尝试获取其他数据');
                    // 如果最新数据不存在，尝试获取列表中的其他数据
                    for (let i = keyList.length - 2; i >= 0; i--) {
                        const data = localStorage.getItem(keyList[i]);
                        if (data) return JSON.parse(data);
                    }
                    return null;
                }
                
                return JSON.parse(storedData);
            } catch (error) {
                console.error('读取模型数据时出错:', error);
                return null;
            }

        }
        // 响应窗口大小变化
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight ;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>


</body>
</html>